---
layout: post
title: "TTT GUI"
date: 2025-08-11 16:45:00 -0400
categories: apprenticeship update
---

Today’s task was pretty straightforward:

- Build a 3×3 clickable board
- Mark an X when a cell is clicked
- Show a “Game Over!” message when the board is full

But this was my first real dive into interacting with a Clojure GUI, and I
learned something new, the :mouse-clicked event.

In GUI programming, a :mouse-clicked event is your way of saying: “Hey! The
user just clicked somewhere on the screen!”

Here’s my current function for handling it:

```clojure

(defn mouse-clicked [state event]
      (let [col (int (/ (:x event) cell-size))
            row (int (/ (:y event) cell-size))
            board (:board state)]
           (if (and (nil? (get-in board [row col])) (nil? (:message state)))
             (let [new-board (assoc-in board [row col] :x)
                   msg (when (all-filled? new-board) "Game Over!")]
                  (assoc state :board new-board :message msg))
             state)))

```

Get the click coordinates
Every click comes with an (x, y) location.
Dividing by cell-size tells us which cell the click landed in:

```clojure

(int (/ (:x event) cell-size)) ;; column
(int (/ (:y event) cell-size)) ;; row

```

Check if the cell is empty and the game isn’t over

```clojure

(nil? (get-in board [row col])) ;; no mark here yet
(nil? (:message state)) ;; no "Game Over" message yet

```

Update the board
If the click is valid, we use assoc-in to place an :x in that spot:

```clojure

(assoc-in board [row col] :x)

```

Check if the board is full
If all-filled? returns true, we set a "Game Over!" message.

The grid math felt familiar thanks to my work on Langton’s Ant, but connecting
it to an interactive click was brand new. It’s one thing to draw a grid, it’s
another to make it react to the player.